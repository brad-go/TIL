# HashTable (해시 테이블)

![해시테이블](https://media.vlpt.us/images/kimkevin90/post/679a5cc4-7402-43e3-854b-ef3520187cc2/hash%20table.PNG)

&nbsp;해시 테이블은 **대량의 정보를 저장**하고 **특정 요소에 효율적으로 접근**할 수 있는 복잡한 데이터 구조이다. 이 데이터 구조는 테이블 내에 더 작은 서브 그룹인 **버킷(bucket)** 에 **키/값(key/value) 쌍(pair)** 을 저장한다. 예를 들어 사전과 같다고 볼 수 있다.
&nbsp;해시 테이블을 키를 저장할 때에 '**해시 함수(Hash Function)**'를 통해 **해시(hash)라는 특정 숫자값으로 변환**하는데, 이는 메모리 공간을 덜 사용할 수 있게 해준다. 해시 테이블은 필요할 때에만 메모리 크기를 늘리고 가능한 한 작은 크기를 유지한다.

&nbsp;**키(key)** 는 **검색 시 사용되는 문자열(데이터 식별자)** 이고 **값(value)** 은 **해당 키와 쌍을 이룬 데이터(내용)** 다. 검색된 각 키는 미리 정의된 해시함수(hash function)를 통해 해시(hash)값을 받고 버킷(bucket)을 가리킨다. 즉, **해시 숫자는 버킷의 index**라는 뜻이다. 그리고 버킷에서 검색할 때 입력된 키를 찾고 해당 키와 관련된 값을 반환한다

- 데이터를 저장하기 위해 배열을 이용한다.
- 키를 해시함수를 통해 인덱스(얻은 해시값)로 변경해서 배열에 저장한다.
- 다른 키인데도 불구하고 같은 해시값을 통해 같은 인덱스에 저장해야 할 때는 **충돌**이 일어난다.
- 충돌이 일어나면 해 당 인덱스에 리스트 구조로 기존 데이터와 연결한다. 이를 **연쇄법(또는 체이닝(chaining))** 이라고 한다.

&nbsp;충돌 시의 처리 방법에는 연쇄법 이외에도 몇 가지가 있다. 유명한 것으로 '**개방 주소법(open addressing)**'이 있다. 이것은 충돌이 발생한 경우 다음 후보가 될 주소(배열 상의 위치)를 구해서 거기에 저장하는 방식이다.
&nbsp;해당 주소에도 데이터가 존재한다면 다음 후보 주소를 구하여 비어 있는 곳을 찾을 때까지 다음 번 주소를 구한다. '다음 주소'를 구하는 방법에는 해시 함수를 여러 개 사용하는 방법이나 '**선형 탐사**' 등 몇 가지 방법이 있다.

### 장점

- 동적인 메모리 크기(직접 크기를 늘리거나 줄여야 함)
- 해시 함수를 이용해서 배열 내의 특정 데이터에 빠르게 접근할 수 있다.
- 검색, 추가, 삭제가 빠르고 용이하다.
- 해시값이 충돌할 때에는 리스트를 이용하고 있어서 저장할 데이터 수가 정해져 있지 않더라도 유연하게 대응할 수 있다.

### 단점

- 해시 테이블에 사용하는 배열의 크기가 너무 작으면 충돌이 많아지고 선형 탐색의 빈도가 높아지게 된다.
- 배열의 크기가 너무 크게 되면 데이터가 없는 빈 인덱스가 많아져서 메모리를 낭비하게 되므로 적절한 크기의 배열을 설정해야 한다.

### 활용

- 데이터베이스: 주소 찾기, 이름 찾기, 번호 찾기 등
- 사용자 로그인 인증

|                       | 접근        | 추가        | 삭제        |
| --------------------- | ----------- | ----------- | ----------- |
| 해시테이블(HashTable) | 빠름 / O(1) | 빠름 / O(1) | 빠름 / O(1) |
