# 프록시 패턴(Proxy Pattern)

## 프록시 패턴이란?

프록시는 **클라이언트가 사용하는 실제 서비스 객체를 대신하는 객체를 제공하는 구조적 디자인 패턴**입니다. 프록시는 대리인이라는 뜻으로 클라이언트 요청을 수신하고 일부 작업(접근 제어, 캐싱 등)을 수행한 다음 요청을 서비스 객체 전달합니다. 즉, 프록시는 원래 객체 대한 접근을 제어하므로 요청이 원래 객체에 전달되기 전이나 후에 무언가를 수행할 수 있습니다.

### 문제

객체에 대한 접근을 제어하려는 이유가 뭘까요? 한 번 다음 예를 보면서 살펴봅시다. 방대한 양의 시스템 자원을 소비하는 커다란 객체가 있습니다. 이 객체는 때때로 필요하지만, 항상 필요하지는 않습니다.

지연 초기화를 통해서 실제로 필요할 때만 이 객체를 생성할 수도 있습니다. 그러나 객체의 모든 클라이언트는 지연된 초기화 코드를 실행해야 합니다. 따라서 이는 많은 중복 코드를 야기할 수 있습니다.

이상적으로는 이 코드를 객체의 클래스에 직접 넣고 싶지만 항상 가능한 것은 아닙니다. 예를 들어 클래스가 폐쇄된 타사 라이브러리의 일부일 경우가 그렇습니다.

### 해결책

프록시 패턴은 원래 서비스 객체와 동일한 인터페이스로 새 프록시 클래스를 생성하도록 제안합니다. 그런 다음 프록시 객체를 원래 객체의 모든 클라이언트에 전달하도록 앱을 업데이트합니다. 클라이언트로부터 요청을 받으면 프록시는 실제 서비스 객체를 생성하고 모든 작업을 이 객체에 위임합니다.

이를 통해 얻는 이점은 다음과 같습니다.

- **클래스의 기본 로직 이전이나 이후에 무언가를 실행해야 하는 경우 프록시를 사용하면 해당 클래스를 변경하지 않고도 이를 수행**할 수 있습니다.
- 프록시는 원래 클래스와 동일한 인터페이스를 구현하므로 **실제 서비스 객체를 기대하는 모든 클라이언트에 전달**할 수 있습니다.

다른 예시를 하나 더 들어보겠습니다. 신용 카드는 은행 계좌의 대리인이며, 현금의 대리인입니다. 둘 다 동일한 인터페이스를 구현하므로 현금처럼 결제에 사용할 수 있습니다. 많은 현금을 가지고 다닐 필요가 없기 때문에 소비자는 좋고, 상점은 예금을 잃어버리거나 은행에 가는 길에 강도를 당할 위험 없이 거래 수입이 상점의 은행 계좌에 전자적으로 추가되기 때문에 좋습니다.

## 구조

![https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed-2x.png](https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed-2x.png)

- **Service Interface**: 서비스의 인터페이스를 선언합니다. 프록시는 서비스 객체로 위장할 수 있도록 이 인터페이스를 따라야 합니다.
- **Service**: 서비스는 몇 가지 유용한 비즈니스 로직을 제공하는 클래스입니다.
- **Proxy**: 프록시 클래스에는 서비스 객체를 가리키는 참조 필드가 있습니다. 프록시가 처리(예: 지연 초기화, 로깅, 접근 제어, 캐싱 등)를 완료한 후 요청을 서비스 객체에 전달합니다. 일반적으로 프록시는 서비스 객체의 전체 수명 주기를 관리합니다.
- **Client**: 동일한 인터페이스를 통해 서비스와 프록시 모두에서 작업해야 합니다. 이렇게 하면 서비스 객체가 필요한 모든 코드를 프록시를 통해 전달할 수 있습니다.

## 예시 코드

```tsx
/**
 * RealSubject 클래스와 프록시 둘 다에서 사용되는 동작을 선언합니다.
 * 클라이언트가 이 인터페이스롤 RealSubject를 사용하는 한, RealSubject 객체
 * 대신 프록시를 사용할 수 있습니다.
 */
interface Subject {
  request(): void;
}

/**
 * RealSubject는 핵심 비즈니스 로직을 가지고 있습니다. 대개, RealSubject는
 * 입력 데이터 수정과 같이 매우 느리거나 민감한 일부 유용한 작업을 수행할 수
 * 있습니다. 프록시는 RealSubject의 코드를 변경하지 않고, 이러한 문제를 해결할
 * 수 있습니다.
 */
class RealSubject implements Subject {
  request(): void {
    console.log("RealSubject: Handling request.");
  }
}

/**
 * 프록시는 RealSubject와 동일한 인터페이스를 가집니다.
 */
class Proxy implements Subject {
  private realSubject: RealSubject;

  /**
   * 프록시는 RealSubject 객체에 대한 참조를 유지합니다. 이것은 지연 초기화 되거나
   * 클라이언트에 의해 프록시로 전달될 수 있습니다.
   */
  constructor(realSubject: RealSubject) {
    this.realSubject = realSubject;
  }

  /**
   * 프록시 패턴의 가장 흔한 사용은 지연 초기화, 캐싱, 접근 제어, 로깅 등입니다.
   * 프록시는 이러한 작업 중 하나를 수해한 다음 결과에 따라 연결된 RealSubject
   * 객체의 동일한 메서드로 실행을 전달할 수 있습니다.
   */
  request(): void {
    if (this.checkAccess()) {
      this.realSubject.request();
      this.logAccess();
    }
  }

  private checkAccess(): boolean {
    // 진짜 체크하는 코드가 여기에 들어갑니다.
    console.log("Proxy: Checking access prior to firing a real requesst");

    return true;
  }

  private logAccess(): void {
    console.log("Proxy: Logging the time of request");
  }
}

/**
 * 클라이언트 코드는 RealSubject와 프록시를 모두 사용하기 위해 Subject 인터페이스를
 * 통해 모든 객체(Subject와 프록시 모두)와 소통해야 합니다. 그러나 실생활에서
 * 클라이언트들은 대부분 RealSubject를 직접 사용합니다. 이 경우 패턴을 보다 쉽게 구현하기
 * 위해 RealSubject 클래스에서 프록시를 확장할 수 있습니다.
 */
function clientCode(subject: Subject) {
  // ...
  subject.request();
  //. ..
}

console.log("Client: Executing the client code with a real subject: ");
const realSubject = new RealSubject();
clientCode(realSubject);

console.log("");

console.log("Client: Executing the same client code with a proxy: ");
const proxy = new Proxy(realSubject);
clientCode(proxy);

// Client: Executing the client code with a real subject:
// RealSubject: Handling request.

// Client: Executing the same client code with a proxy:
// Proxy: Checking access prior to firing a real request.
// RealSubject: Handling request.
// Proxy: Logging the time of request.
```

- [다른 예시 1](./youtube.ts)
- [다른 예시 2](./printer.ts)
- [다른 예시 3](./phoneBook.ts)

## 언제 사용해야할까?

프록시 패턴을 활용하는 방법은 많이 있습니다. 대표적인 사용 사례를 알아보죠.

- **지연 초기화(가상 프록시)**: **필요할 때만 사용하지만, 항상 존재해서 시스템 자원을 낭비하는거대한 서비스 객체가 있을 때** 사용할 수 있습니다. 앱이 시작될 때 객체를 생성하는 대신에 객체의 초기화를 진짜 필요할 때까지 초기화를 지연시킵니다.
- **접근 제어(보호 프록시): 특정한 클라이언트가 서비스 객체를 이용하기를 원할 때** 사용할 수 있습니다. 예를 들어 객체가 운영 체제의 중요한 부분이고 클라이언트가 다양한 시작 애플리케이션(악성 애플리케이션 포함)인 경우입니다. 클라이언트의 자격이 일부 조건과 일치하는 경우에만 프록시가 서비스 객체로 요청을 전달하게 할 수 있습니다.
- **원격 서비스의 로컬 실행(원격 프록시)**: **서비스 객체가 원격 서버에 경우**입니다. 이 경우 프록시는 네트워크를 통해 클라이언트 요청을 전달하여 네트워크 작업의 모든 세부 사항을 처리합니다.
- **로깅 요청(로깅 프록시)**: **서비스 객체에 대한 요청 기록을 유지하려는 경우**입니다. 프록시는 서비스에 저달하기 전에 각 요청을 기록할 수 있습니다.
- **캐싱 요청 결과(캐싱 프록시)**: **클라이언트의 요청 결과를 캐시하고 이 캐시의 생명 주기를 관리해야 하는 경우**입니다. 특히 결과가 상당히 큰 경우에 사용합니다. 프록시는 항상 동일한 결과를 생성하는 반복 요청에 대해 캐싱을 구현할 수 있습니다. 프록시는 요청의 매개변수를 캐시 키로 사용할 수 있습니다.
- **스마트 참조**: **무거운 객체를 사용하는 클라이언트가 없을 때 해제할 수 있어야 할 때**입니다.
  프록시는 서비스 객체 또는 해당 결과에 대한 참조를 얻은 클라이언트를 추적할 수 있습니다. 때때로 프록시는 클라이언트를 통해 클라이언트가 여전히 활성 상태인지 확인할 수 있습니다. 클라이언트 목록이 비어있으면, 프록시가 서비스 객체를 닫고 기본 시스템 자원을 해제할 수 있습니다.
  프록시는 클라이언트가 서비스 객체를 수정했는지 여부도 추적할 수 있습니다. 그런 다음 변경되지 않은 객체는 다른 클라이언트에서 재사용할 수 있습니다.

## 구현 방법

1. 기존 서비스 인터페이스가 없는 경우 프록시와 서비스 객체를 교환할 수 있도록 생성합니다. 서비스 클래스에서 인터페이스를 추출하는 것이 항상 가능한 것은 아닙니다. 해당 인터페이스를 사용하려면 서비스의 모든 클라이언트를 변경해야하기 때문입니다. 차선책으로 프록시를 클래스의 하위 클래스로 만들고 서비스의 인텊이스를 상속받을 수 있습니다.
2. 프록시 클래스를 만듭니다. 서비스에 대한 참조를 저장하기 위한 필드가 있어야 합니다. 일반적으로 프록시는 서비스의 전체 수명 주기를 생성하고 관리합니다. 드문 경우지만 클라이언트가 생성자를 통해 서비스를 프록시에 전달합니다.
3. 목적에 따라 프록시 메서드를 구현합니다. 대부분의 경우 일부 작업을 수행한 후 프록시는 작업을 서비스 객체에 위임합니다.
4. 클라이언트가 프록시를 받을지, 실제 서비스를 받을지를 결정하는 생성 메서드를 만들 것을 고려해야 합니다. 이것은 프록시 클래스의 간단한 정적 메서드 또는 본격적인 팩토리 메서드가 될 수 있습니다.
5. 서비스 객체에 대한 지연 초기화 구현을 고려합니다.

## 장점과 단점

### 장점

- 클라이언트가 알지 못하는 상태에서 서비스 객체를 제어할 수 있습니다.
- 클라이언트와는 독립적으로 서비스 객체의 생명 주기를 관리할 수 있습니다.
- 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 동작합니다.
- 서비스나 클라이언트를 변경하지 않고, 새 프록시를 도입할 수 있으므로 개방 폐쇄 원칙을 준수합니다.

### 단점

- 많은 새 클래스를 도입해야 하므로 코드가 더 복잡해질 수 있습니다.
- 서비스의 응답이 늦어질 수 있습니다.

## 다른 패턴과의 관계

- [어댑터 패턴](../Adapter/)은 감싸진 객체에 대해 다른 인터페이스를 제공하고, [프록시](../Proxy/) 패턴은 동일한 인터페이스를 제공하며 [데코레이터](../Decorator/) 패턴은 향상된 인터페이스를 제공합니다.
- [퍼사드](../Facade/)는 복잡한 엔티티로부터의 완충장치 역할을 하고, 자체적으로 초기화한다는 점에서 [프록시](../Proxy/) 패턴과 유사합니다. 그러나 퍼사드 패턴과 달리 프록시 패턴은 서비스 객체와 동일한 인터페이스를 가지고 있어 상호 교환이 가능합니다.
- [데코레이터](../Decorator/) 패턴과 [프록시](../Proxy/) 패턴은 비슷한 구조를 가지지만 엄연히 다른 목적으로 사용됩니다. 두 패턴은 조합(composition) 원칙에 기초하고 있으며, 이 원칙에서 한 객체는 작업의 일부를 다른 객체에 위임해야 합니다. 차이는 프록시 패턴은 일반적으로 서비스 객체의 생명 주기를 스스로 관리하는 반면, 데코레이터들의 조합은 항상 클라이언트에 의해 제어됩니다.

## 참고

- [Proxy in TypeScript](https://refactoring.guru/design-patterns/proxy/typescript/example)
- [JavaScript 프록시(Proxy)](https://hyunseob.github.io/2016/08/17/javascript-proxy/)
