# 9장 타입 변환과 단축 평가

## 목차

1. [타입 변환이란?](#1-타입-변환이란)
2. [암묵적 타입 변환](#2-암묵적-타입-변환)
3. [명시적 타입 변환](#3-명시적-타입-변환)
4. [단축 평가](#4-단축-평가)

## 1. 타입 변환이란?

자바스크립트의 모든 값은 타입이 있습니다. 이 타입은 다른 타입으로 변환이 가능한데, **개발자가 의도적으로 타입을 변환하는 것**을 **명시적 타입 변환(explicit coercion)** 또는 **타입 캐스팅(type casting)** 이라고 합니다.

```jsx
var x = 10;

// 명시적 타입 변환. 숫자 -> 문자열
var str = x.toString();

console.log(typeof str, str); // string 10

// 변수 x의 값이 변경된 것은 아닙니다.
console.log(typeof x, x); // number 10
```

**개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환**되기도 하는데, 이를 **암묵적 타입 변환(implicit coercion)** 또는 **타입 강제 변환(type coercion)** 이라고 합니다.

```jsx
var x = 10;

// 암묵적 타입 변환. 숫자 -> 문자열
var str = x + "";

console.log(typeof str, str); // string 10

// 변수 x의 값이 변경된 것은 아닙니다.
console.log(typeof x, x); // number 10
```

위 두 예제에서 볼 수 있듯이, **명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아닙니다**. 원시 값은 변경 불가능한 값(immutable value)이므로 변경할 수 없습니다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것입니다.

## 2. 암묵적 타입 변환

```jsx
// 피연산자가 모두 문자열 타입이어야 하는 문맥
"10" + 2;

// 피연산자가 모두 숫자 타입이어야 하는 문맥
5 * "10";

// 피연산자 또는 표현식이 불리언 타입이어야 하는 문맥
!0; // -> true
if (1) {
}
```

위처럼 표현식을 평가할 때, 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있습니다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 **자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가**합니다.

**암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환**합니다. 몇 가지 예시를 보면서 타입 별로 암묵적 타입 변환이 어떻게 발생하는지 알아봅시다.

### 2-1. 문자열 타입으로 변환

자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 **문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환**합니다.

```jsx
1 + "2"; // -> '12
```

### 2-2. 숫자 타입으로 변환

자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 **산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적으로 타입 변환**합니다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 `NaN`이 됩니다.

```jsx
1 - "1"; // -> 0
1 * "10"; // -> 10
1 / "one"; // -> NaN
```

### 2-3. 불리언 타입으로 변환

if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가되어야 하는 표현식입니다. 자바스크립트 엔진은 **조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환**합니다.

이때 **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분**합니다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 `true`로, Falsy값은 `false`로 암묵적 타입 변환됩니다.

아래 값들은 `false`로 평가되는 Falsy 값입니다.

- `false`
- `undefined`
- `null`
- `0`, `-0`
- `NaN`
- `‘’`(빈 문자열)

Falsy 값 외의 모든 값은 `true`로 평가되는 Truthy 값입니다.

## 3. 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양합니다. 표준 빌트인 생성자 함수(`String`, `Number`, `Boolean`)를 `new` 연산자 없이 호출하는 방법과 빌트인 메서드를 이용하는 방법, 암묵적 타입 변환을 이용하는 방법이 있습니다.

### 3-1. 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같습니다.

1. `String` 생성자 함수를 `new` 연산자 없이 호출하는 방법
2. `Object.prototype.toString` 메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

```jsx
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
String(1); // -> '1'
String(true); // -> 'true'

// 2. Object.prototype.toString 메서드를 사용하는 방법
(1).toString(); // -> '1'
true.toString(); // -> 'true'

// 3. 문자열 연결 연산자를 이용하는 방법
1 + ""; // -> '1'
true + ""; // -> 'true'
```

### 3-2. 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같습니다.

1. `Number` 생성자 함수를 `new` 연산자 없이 호출하는 방법
2. `parseInt`, `parseFloat` 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
3. `+` 단항 산술 연산자를 이용하는 방법
4. `*` 산술 연산자를 이용하는 방법

```jsx
// 1. `Number` 생성자 함수를 `new` 연산자 없이 호출하는 방법
Number("0"); // -> 0
Number("10.53"); // -> 10.53
Number(true); // -> 1

// 2. `parseInt`, `parseFloat` 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
parseInt("0"); // -> 0
parseFloat("10.53"); // -> 10.53

// 3. `+` 단항 산술 연산자를 이용하는 방법
+"0"; // -> 0
+"10.53"; // -> 10.53
+true; // -> 1

// 4. `*` 산술 연산자를 이용하는 방법
"0" * 1; // -> 0
"10.53" * 1; // -> 10.53
true * 1; // -> 1
```

### 3-3. 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같습니다.

1. `Boolean` 생성자 함수를 `new` 연산자 없이 호출하는 방법
2. `!` 부정 논리 연산자를 두 번 사용하는 방법

```jsx
// 1. `Boolean` 생성자 함수를 `new` 연산자 없이 호출하는 방법
Boolean(""); // -> false
Boolean("false"); // -> true
Boolean(0); // -> false
Boolean(null); // -> false
Boolean(Infinity); // -> true
Boolean({}); // -> true
Boolean([]); // -> true

// 2. `!` 부정 논리 연산자를 두 번 사용하는 방법
!!""; // -> false
!!"false"; // -> true
!!0; // -> false
!!null; // -> false
!!Infinity; // -> true
!!{}; // -> true
!![]; // -> true
```

## 4. 단축 평가

### 4-1. 논리 연산자를 사용한 단축 평가

논리합(`||`) 또는 논리곱(`&&`) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있으며, 언제나 2개의 피연산자 중 어느 한쪽으로 평가될 수 있습니다. 다음 코드는 어떤 값으로 평가될까요?

```jsx
"Cat" && "Dog"; // -> 'Dog'
```

논리곱(`&&`) 연산자는 **두 개의 피연산자가 모두 `true`로 평가될 때 `true`를 반환**합니다. 그렇다면 위 표현식은 두 개의 Truthy값의 피연산자와 논리곱 연산자로 이루어져있으니 `true`를 반환할 것 같지만 ‘Dog’로 평가됩니다.

위 표현식의 평가 과정을 살펴보면서 자세히 알아보죠. 논리곱 연산자는 **좌항에서 우항으로 평가가 진행**됩니다. 첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 `true`로 평가됩니다. 하지만 이 시점까지는 위 표현식을 평가할 수 없습니다. 두 번째 피연산자까지 평가해봐야 위 표현식을 평가할 수 있습니다. 다시 말해, 두 번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정하게됩니다. 이때 논리곱 연산자는 **논리 연산의 결과를 결정하는 두 번째 피연산자, 즉 문자열 ‘Dog’를 그대로 반환**합니다.

```jsx
"Cat" || "Dog"; // -> 'Cat'
```

논리합(`||`) 연산자는 어떨까요? 논리합 연산자는 **두 개의 피연산자 중 하나만 `true`로 평가되어도 `true`를 반환**합니다. 논리합 연산자도 **좌항에서 우항으로 평가가 진행**됩니다.

첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가됩니다. 이 시점에 두 번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있습니다. 이때 논리합 연산자는 **논리 연산의 결과를 결정한 첫 번째 피연산자, 즉 문자열 ‘Cat’을 그대로 반환**합니다.

**논리곱(&&) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환**하는데, 이를 **단축 평가(short-circuit evaluation)** 라고합니다. **단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것**을 말합니다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행합니다.

단축 평가는 다음 규칙을 따릅니다.

| 단축 평가 표현식    | 평가 결과 |
| ------------------- | --------- | ---------- | -------- |
| true `              |           | ` anything | true     |
| false `             |           | ` anything | anything |
| true `&&` anything  | anything  |
| false `&&` anything | false     |

단축 평가를 사용하면 `if` 문을 대체할 수 있습니다. 조건이 Truthy 값(참으로 평가되는 값)이라면 논리곱(`&&)` 연산자 표현식, 조건이 Falsy 값(거짓으로 평가되는 값)이라면 논리합(`&&`) 연산자 표현식으로 `if` 문을 대체할 수 있습니다.

```jsx
var done = true;
var message = "";

// 주어진 조건이 true일 때
message = done && "완료";
console.log(message); // 완료

done = false;

message = done || "미완료";
console.log(message); // 미완료
```

### 4-2. 옵셔널 체이닝 연산자

**옵셔널 체이닝(optional chaning) 연산자 `?.`는 좌항의 피연산자가 `null` 또는 `undefined`인 경우 `undefined`를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어갑니다**.

```jsx
var elem = null;

var value = elem?.value;
console.log(value); // undefined
```

옵셔널 체이닝 연산자 `?.`는 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined`가 아닌지 확인하고 프로퍼티를 참조할 때 유용합니다. 옵셔널 체이닝 연산자가 도입되기 전에는 논리 연산자 `&&`를 사용한 단축 평가를 통해 변수가 `null` 또는 `undefined`인지 확인했습니다.

```jsx
var elem = null;

// elem이 Falsy 값이면 elem으로 평가되고, elem이 Truthy 값이면 elem.value로 평가됩니다.
var value = elem && elem.value;
console.log(value); // null
```

논리 연산자 `&&`는 좌항 피연산자가 `false`로 평가되는 Falsy 값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `‘’`)이면 좌항 피연산자를 그대로 반환합니다. 그러나 `0`이나 `‘’`은 객체로 평가될 때도 있습니다. 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 임시 객체인 래퍼 객체(wrapper object)가 생성되기 때문이죠. 그래서 다음 코드처럼 예상한 대로 값이 평가되지 않을 수 있습니다.

```jsx
var str = "";

var length = str && str.length;

// 문자열의 길이(length)를 참조하지 못합니다.
console.log(length);
```

하지만 옵셔널 체이닝 연산자 `?.`는 좌항 피연산자가 `false`로 평가되는 Falsy값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `‘’`)이라도 `null` 또는 `undefined`가 아니면 우항의 프로퍼티 참조를 이어갑니다.

```jsx
var str = "";

// 좌항 피연산자가 false로 평가는 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어갑니다.
var length = str?.length;
console.log(length); // 0
```

### 4-3. null 병합 연산자

**null 병합(nullish coalescing) 연산자 `??`는 좌항의 피연산자가 `null` 또는 `undefined`인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환**합니다. null 병합 연산자 `??`는 변수에 기본값을 설정할 때 유용합니다.

```jsx
var foo = null ?? "default string";
console.log(foo); // "default string"
```

null 병합 연산자 `??`가 도입되기 전에는 논리 연산자 `||`를 사용한 단축 평가를 통해 변수에 기본값을 설정했습니다. 논리 연산자 `||`를 사용한 단축 평가의 경우 좌항의 피연산자가 `false`로 평가되는 Falsy값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `‘’`)이면 우항의 피연산자를 반환합니다. 그러나 Falsy 값인 `0`이나 `‘’`도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있습니다.

```jsx
var foo = "" || "default string";
console.log(foo); // "default string"
```

하지만 null 병합 연산자 ??는 좌항의 피연산자가 `false`로 평가되는 Falsy값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `‘’`)이라도 `null` 또는 `undefined`가 아니라면 좌항의 피연산자를 그대로 반환합니다.

```jsx
var foo = "" ?? "default string";
console.log(foo); // ''
```
