# V8 엔진의 Hidden Class

자바스크립트 딥다이브를 읽다가 자바스크립트 객체의 관리 방식에 대한 글을 보게 되었습니다. 자바스크립트는 객체의 프로퍼티에 접근하기 위해 히든 클래스(hidden class)라는 방식을 사용한다는 것입니다. 자바스크립트에 히든 클래스가 있다니? 한번 알아보겠습니다.

글을 읽기 전에 해당 글은 자바스크립트 딥다이브와 [V8의 히든 클래스 이야기](https://engineering.linecorp.com/ko/blog/v8-hidden-class)를 인용해서 작성한 글임을 알립니다.

## 자바스크립트의 객체 관리 방식

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있습니다. 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만, 더 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현합니다.

자바, C++과 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체(인스턴스)를 생성합니다. 다시 말해, 객체 생성 전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체를 생성하는 것입니다. 객체를 생성한 이후로는 프로퍼티나 메서드의 추가, 삭제가 불가능하죠.

하지만 자바스크립트는 클래스 없이 객체를 생성할 수 있으며, 객체를 생성한 후에도 동적으로 프로퍼티와 메서드를 추가할 수 있습니다. 이는 사용하기 매우 편리하지만, 성능 면에서는 이론적으로 클래스 기반 객체지향 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식입니다.

그 이유는 자바스크립트 객체의 데이터 타입이 동적으로 정해지기 때문에 메모리 오프셋을 컴파일 시에 결정할 수 없기 때문입니다. 프로퍼티를 선언했을 때의 프로퍼티의 데이터 타입이나 순서가 실제로 프로퍼티 값을 접근할 때는 달라질 수 있기 때문이죠. 따라서 프로퍼티 값을 읽어야 할 때마다 프로퍼티를 찾아야 하는데, 즉 동적 탐색(dynamic lookup)이 필요하게 됩니다.

- offset(오프셋): 배열이나 객체 내의 오프셋은 일반적으로 동일 프로젝트 안에서 객체에 처음부터 주어진 요소나 지점까지 변위차를 나타내는 정수형을 말합니다. 즉, 기준이 되는 주소로부터 얼마나 떨어져 있는지 나타내는 값을 말합니다.

## 동적 탐색을 회피하기 위한 히든 클래스

V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색대신 히든 클래스(hidden class)라는 방식을 사용해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장합니다. 히든 클래스는 자바와 같이 고정된 객체 레이아웃(클래스)와 유사하게 동작하는데, **히든 클래스는 본질적으로 객체가 생성되기 전에 객체의 모양을 미리 정의하는 방법**입니다. 즉, 프로퍼티가 바뀔 때 각각 그 프로퍼티의 오프셋을 업데이트한 뒤 그 값을 가지고 있는 방식입니다.

히든 클래스에는 다음과 같은 특징이 있습니다.

- 객체는 반드시 하나의 히든 클래스를 참조합니다.
- 히든 클래스는 각 프로퍼티에 대해 메모리 오프셋을 가지고 있습니다.
- 동적으로 새로운 프로퍼티가 만들어질 때, 혹은 기존 프로퍼티가 삭제되거나 기존 프로퍼티의 데이터 타입이 바뀔 때는 신규 히든 클래스가 생성되며, 신규 히든 클래스는 기존 프로퍼티에 대한 정보를 유지하면서 추가적으로 새 프로퍼티의 오프셋을 가지게 됩니다.
- 히든 클래스는 프로퍼티에 대해 변경이 발생했을 때, 참조해야 하는 히든 클래스에 대한 정보를 갖습니다.
- 객체에 새로운 프로퍼티가 만들어지면, 현재 참조하고 있는 히든 클래스의 전환 정보를 확인한 후, 현재 프로퍼티에 대한 변경이 전환 정보의 조건과 일치하면, 객체의 참조 히든 클래스를 조건에 명시된 히든 클래스로 변경시킵니다.

위 특징들을 바탕으로 히든 클래스의 생성 과정에 대해 알아보겠습니다.

```js
// 객체가 생성될 때, 히든 클래스 H0이 생성. obj -> H0
var obj = {};
```

객체가 생성될 때는 반드시 히든 클래스가 생성됩니다. 즉, 위와 같은 코드가 실행되면 히든 클래스가 생성되며, `obj` 객체는 생성된 히든 클래스와 연결됩니다. 현재 히든 클래스를 편의상 `H0`이라고 부르겠습니다. 이때 히든 클래스 `H0`에는 아무런 정보도 없는 상태입니다. `obj` 객체가 프로퍼티를 갖고 있지 않기 때문입니다.

```js
// obj -> H0
var obj = {};
// obj -> H1
obj.x = 1;
```

객체를 생성한 후 위와 같이 `obj.x` 프로퍼티에 값을 대입합니다. 이때 객체에 동적으로 새로운 프로퍼티가 만들어졌기 때문에, 새로운 히든 클래스 `H1`이 생성되며, `x` 프로퍼티에 대한 오프셋 값을 가집니다. `obj` 객체는 이제 히든 클래스 H1을 참조합니다. 또, '`x`를 추가하면 히든 클래스가 H1으로 전환(transition)된다'는 정보가 히든 클래스 H0에 저장됩니다.

```js
// obj -> H0
var obj = {};
// obj -> H1
obj.x = 1;
// obj -> H2
obj.y = 1;
```

이번에는 `obj.y` 프로퍼티에 값을 대입합니다. 다시 새로운 히든 클래스 `H2`가 생성되고, `obj` 객체에 대응하는 히든 클래스가 `H1`에서 `H2`로 바뀝니다. `H1` 클래스에 `y` 프로퍼티에 대한 오프셋 값을 추가하는 것이 아닙니다. 마찬가지로 `H1` 클래스에는 '`y`를 추가하면 참조하는 히든 클래스가 H2로 변경된다'는 정보가 더해집니다.

이와 같이 히든 클래스 간의 연쇄 고리가 만들어진 후, 가령 `obj.y` 프로퍼티에 대한 접근이 있었다고 가정해 봅시다. 이때 `obj` 객체와 연결된 히든 클래스를 찾습니다. 이때의 참조 히든 클래스는 `H2` 클래스이므로 `H2` 클래스에 적혀있는 `y` 프로퍼티의 오프셋을 이용해서 `y`의 값을 참조하게 됩니다. 이것이 바로 V8이 사용하는 동적 탐색을 회피하는 기본적인 방식입니다.

## 히든 클래스의 효율을 높여주는 '전환 정보'

위에서 한 객체의 히든 클래스가 생긴 후에 해당 객체에 프로퍼티가 새롭게 추가되어 새로운 히든 클래스가 생성될 때, 기존 히든 클래스에는 새로운 히든 클래스에 대한 전환(transition) 정보가 기록된다고 했습니다. 한번 자세히 알아볼까요?

```js
function Person(name) {
  this.name = name;
}

var foo = new Person("brad");
var bar = new Person("karina");

console.log(bar.name);
```

`var foo = new Person('brad');`가 실행된 시점에는 `foo` 객체는 `H1` 클래스를 참조하고 있는 상태입니다.

- 히든 클래스 `H0`
  - 프로퍼티의 오프셋 값 없음
  - '`name`을 추가하면 `H1`으로 전환된다'는 정보가 있음
- 히든 클래스 `H1`
  - `name`의 오프셋 값

이어서 `bar` 객체가 생성되는데, 이 과정에서 `bar` 객체가 `H0` 클래스를 참조했을 때 거기에는 이미 '`name을` 추가하면 `H1` 클래스로 전환된'는 정보가 있습니다. 그러므로 `bar` 객체는 다음에 `name`을 추가할 때 새로운 히든 클래스를 생성하지 않고, `H1` 클래스를 참조하여, 자기 자신과 `H1` 클래스를 연결시킵니다. 이렇게 히든 클래스를 쓸데없이 늘리지 않으면서 오프셋을 효율적으로 관리하는 목적을 달성합니다.

## 히든 클래스와 인라인 캐싱

V8에서는 히든 클래스외에 최적화를 위해 인라인 캐싱(inline caching)이라는 기술을 사용합니다. **인라인 캐싱은 V8이 함수 조회 결과를 캐싱하여 함수 조회 결과를 캐싱하여 함수 호출을 최적화할 수 있도록 하는 메커니즘**입니다. 함수가 호출되면 V8은 매개변수로 전달되는 객체의 히든 클래스를 확인합니다. 히든 클래스가 이전 함수 호출과 일치하면 V8은 캐시된 결과를 사용해서 함수 호출을 최적화합니다.

다음의 예시를 보면서 더 자세히 알아보겠습니다.

```js
function greetPerson(person) {
  // 함수 호출시 V8은 객체에서 프로퍼티를 찾아야 합니다.
  console.log(`Hello, ${person.name}!`);
}

const person1 = { name: "Alice", age: 30 };
const person2 = { name: "Bob", age: 40 };

// 각 객체가 호출될 때, 객체의 히든 클래스를 확인해서 객체의 구조를 결정하고 캐싱
// 히든 클래스에는 객체의 프로퍼타, 타입 및 메모리 주소에 대한 정보 포함
greetPerson(person1); // Hello, Alice!
greetPerson(person2); // Hello, Bob!

// 동일한 객체로 함수가 호출되면 V8은 히든 클래스 및 프로퍼티를 조회하는 프로세스를 건너뜁니다.
greetPerson(person1); // Hello, Alice!
```

## 히든 클래스와 인라인 캐싱의 최적화

히든 클래스라는 개념은 겉으로 들어나지 않지만, 프로퍼티 값을 참조할 때 발생하는 속도 저하를 막기 위한 하나의 장치임을 알 수 있습니다. 히든 클래스가 있다고 해도 유지 중인 오프셋을 사용해서 메모리를 참조하는 작업은 여전히 남아있는데, 이 작업이 같은 조건 하에서 여러 번 반복될 때, 결과를 캐싱해서 전달하는 역할을 하는 것이 인라인 캐싱의 역할이었습니다.

이 두가지 최적화는 객체의 프로퍼티 조회 및 함수 호출에 소요되는 시간을 줄여 자바스크립트 코드의 성능을 크게 향상시켜줍니다. 하지만 인라인 캐싱의 효과는 코드 구조와 사용 중인 객체의 타입에 따라 다르다는 점에 유의해야 합니다.

## 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)
- [V8의 히든 클래스 이야기](https://engineering.linecorp.com/ko/blog/v8-hidden-class)
