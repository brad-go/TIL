# 데이터타입

## 목차

1. [데이터 타입의 종류](#1-데이터-타입의-종류)
2. [숫자 타입](#2-숫자-타입)
3. [문자열 타입](#3-문자열-타입)
4. [불리언 타입](#4-불리언-타입)
5. [undefined 타입](#5-undefined-타입)
6. [null 타입](#6-null-타입)
7. [Symbol 타입](#7-심벌-타입)
8. [기본형 vs 참조형](#8-기본형-vs-참조형)
9. [데이터 타입의 필요성](#9-데이터-타입의-필요성)
10. [동적 타이핑](#10-동적-타이핑)

## 1. 데이터 타입의 종류

데이터 타입(data type)은 값의 종류를 말하며, 자바스크립트의 모든 값은 데이터 타입을 갖습니다. 자바스크립트의 데이터 타입에는 크게 두 가지가 있는데, **기본형(원시 타입, primitive type)** 과 **참조형(객체 타입, object/reference type)** 입니다.

### 기본형(primitive type)

- **숫자(number)**: 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재
- **문자열(string)**: 문자열
- **불리언(boolean)**: 논리적 참(true)과 거짓(false)
- **undefined**: var 키워드로 선언된 변수에 암묵적으로 할당되는 값
- **null**: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
- **심벌(symbol)**: ES6에서 추가된 7번째 타입

### 참조형(reference type)

- 객체, 함수, 배열, 정규식, Map, Set 등을 나타내는 타입

자바스크립트는 ES6 기준 위처럼 총 7가지의 데이터 타입을 갖습니다. 각각의 데이터 타입마다 생성 목적과 용도가 다르며, 확보해야 할 메모리 공간의 크기도 다르고, 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다릅니다.

[⬆ Back to top](#목차)
<br />

## 2. 숫자 타입

C나 자바는 정수와 실수를 구분해서 `int`, `long`, `float`, `double` 등과 같은 숫자 타입을 제공합니다. 하지만 자바스크립트는 하나의 숫자 타입만 존재합니다.

ECMAScript 사양에 따르면 숫자 타입의 값은 double-precision floating-point format(배정밀도 64비트 부동소수점 형식)을 따릅니다. 즉, **모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 존재하지 않습니다**.

```jsx
// 모두 숫자 타입입니다.
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장됩니다. 자바스크립트는 2진수, 8진수, 16진수 등을 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 **모두 10진수로 해석**됩니다.

```jsx
// 표기법만 다를 뿐 모두 같은 값입니다.
var binary = 0b01000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

console.log(binary); // 65
console.log(binary === octal); // true
console.log(octal === hex); // true
```

자바스크립트에서 나누기 연산을 하다보면 정수가 실수가 되고 하는 등의 경우가 발생하는데, 이는 자바스크립트가 모든 수를 실수로 처리하기 때문입니다.

```jsx
// 숫자 타입은 모두 실수로 처리됩니다.
console.log(1 === 1.0); // true
console.log(3 / 2); // 1.5
```

숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있습니다.

- **Infinity**: 양의 무한대
- **-Infinity**: 음의 무한대
- **NaN**: 산술 연산 불가(not a number)

```jsx
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN
```

자바스크립트는 대소문자를 구별(case-sensitive)하므로 `NaN`을 NAN, Nan, nan과 같이 표현하면 에러가 발생하므로 주의해야 합니다. 자바스크립트는 NAN, Nan, nan을 값이 아닌 식별자로 해석합니다.

```jsx
var x = nan; // ReferenceError: nan is not defined
```

[⬆ Back to top](#목차)
<br />

## 3. 문자열 타입

**문자열 타입은 텍스트 데이터를 나타내는 데 사용**합니다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있습니다.

문자열은 작은따옴표(`’’`), 큰따옴표(`””`), 백틱(````)으로 텍스트를 감싸서 사용할 수 있습니다. 일반적으로는 작은 따옴표를 사용합니다.

```jsx
var string = "hello";
```

다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이뉴는 키워드나 식별자 같은 토큰과 구분하기 위해서입니다. 만약 문자열을 따옴표로 감싸지 않으면, 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식하게 됩니다.

```jsx
var string = hello; // ReferenceError: hello is not defined
```

C는 문자의 배열로 문자열을 표현하고, 자바는 문자열을 객체로 표현합니다. 그러나 **자바스크립트의 문자열은 기본형(원시 타입)이며, 변경 불가능한 값(immutable value)** 입니다. 이것은 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미합니다.

원시값을 저장하기 위해서는 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 합니다. 이를 위해 자바스크립트의 원시 타입별들은 각각의 타입 별로 메모리 공간의 크기가 미리 정해져 있습니다.

**문자열은 0개 이상의 문자(character)로 이뤄진 집합**을 말하며, **1개의 문자는 2바이트의 메모리 공간에 저장**됩니다. 따라서 **문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정**됩니다. 숫자 값은 1도, 1000000도 동일한 8바이트가 필요하지만, 문자열의 경우 간단히 계산해서 1개의 문자로 이뤄진 문자열은 2바이트, 10개의 문자로 이뤄진 문자열은 20바이트가 필요합니다.

### 문자열과 불변성

```jsx
// 문자열은 0개 이상의 문자로 이뤄진 집합입니다.
var str1 = ""; // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2 = "Hello"; // 5개의 문자로 이뤄진 문자열
```

자바스크립트는 문자열은 기본형(원시 타입)이며 변경 불가능하다고 했습니다. 다음 코드를 보면서 알아보겠습니다.

```jsx
var str = "Hello";
str = str + "world";
```

변수 `str`에 문자열 ‘Hello’를 할당했다가 뒤에 ‘world’를 추가하면 기존의 ‘Hello’가 ‘Hello world’로 바뀌는 것이 아니라 새로운 문자열 ‘Hello world’를 만들어 그 주소를 변수 `str`에 저장합니다. 따라서 ‘Hello’와 ‘Hello wolrd’는 완전히 별개의 데이터로 모두 메모리에 존재합니다. 식별자 `str`은 ‘Hello’를 가리키고 있다가 ‘Hello world’를 가리키도록 변경되었을 뿐입니다.

이번에는 문자열의 한 문자를 변경해봅시다. 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있습니다.

```jsx
var str = "hello";

// 문자열은 유사 배열 객체이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있습니다.
// 하지만 문자열은 원시값이므로 변경할 수 없습니다. 그러나 에러는 발생하지 않습니다.
str[0] = "H";

console.log(str); // hello
```

기본형(원시 타입)인 문자열은 변경 불가능한 값이므로, str[0] = ‘H’처럼 이미 생성된 문자열의 일부를 변경해도 반영되지 않습니다. 이처럼 **한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없습니다**. **원시 값은 어떤 일이 있어도 불변**합니다. 따라서 **예기치 못한 변경으로부터 자유롭고, 이는 데이터의 신뢰성을 보장**합니다.

[⬆ Back to top](#목차)
<br />

## 4. 불리언 타입

불리언 타입의 값은 놀리적 참, 거짓을 나타내는 `true`와 `false`뿐입니다.

```jsx
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에 자주 사용됩니다.

[⬆ Back to top](#목차)
<br />

## 5. undefined 타입

undefined 타입의 값은 `undefined`가 유일합니다.

`undefined`는 사용자가 명시적으로 지정할 수도 있지만, 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있습니다. 자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로 그렇게 하지 않았을 때, `undefined`를 반환합니다.

- 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
- return문이 없거나 호출되지 않는 함수의 실행 결과

```jsx
var foo;
console.log(foo); // undefined. 값을 대입하지 않은 변수에 접근

var obj = { a: 1 };
console.log(obj.b); // undefined. 존재하지 않는 프로퍼티에 접근

var func = function () {};
var c = func();
console.log(c); // undefined. 반환 값이 없는 함수의 실행 결과
```

`var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화됩니다. 다시 말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값이 들어 있습니다)로 내버려두지 않고, 자바스크립트 엔진이 `undefined`로 초기화합니다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 `undefined`가 반환됩니다.

그러나 ES6에서 등장한 `let`, `const`에 대해서는 `undefined`를 할당하지 않은 채로 초기화를 마치며, 이후 특정 값을 할당하기 전까지는 해당 변수에 접근할 수 없습니다.

이처럼 `undefined`는 **개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값**입니다. 변수를 참조했을 때 `undefined`가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 즉 초기화되지 않은 변수란 것을 알 수 있습니다.

자바스크립트 엔진이 변수를 초기화하는 데 사용하는 `undefined`를 개발자가 의도적으로 변수에 할당한다면 `undefined`의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않습니다. 변수에 값이 없다는 것을 명시하고 싶을 때는 `null`을 할당합니다.

[⬆ Back to top](#목차)
<br />

## 6. null 타입

null 타입의 값은 `null`이 유일합니다.

프로그래밍 언어에서 **null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재; intentional absence)할 때 사용**합니다. **변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미**입니다. 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것입니다.

```jsx
var foo = "Brad";

// 이전 참조를 제거. foo는 더 이상 'Brad'를 참조하지 않습니다.
foo = null;
```

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 합니다. 예를 들어 HTML 요소를 검색해 반환하는 `document.querySelector` 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러 데신 `null`을 반환합니다.

`null`은 한 가지 주의할 점이 있습니다. 자바스크립트의 자체 버그로 여겨지는데, 바로 `typeof null`이 `object`라는 점입니다. 따라서 어떤 변수의 값이 `null`인지 여부를 판별하기 위해서는 `typeof` 대신 다른 방식으로 접근해야 합니다.

```jsx
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.log(n === undefined); // false
console.log(n === null); // true
```

또, 동등 연산자(`==`)로 비교할 경우 `null`과 `undefined`가 서로 같다고 판단합니다. 그러므로 이 둘을 구분하기 위해서는 일치 연산자(`===`)를 사용해야 합니다.

[⬆ Back to top](#목차)
<br />

## 7. 심벌 타입

**심벌(symbol)은 다른 값과 중복되지 않는 유일무이한 값**입니다. 따라서 **주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용**합니다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만, 심벌은 **Symbol 함수를 호출해 생성**합니다. 이때 생성된 심벌 값은 **외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값**입니다.

```jsx
// 심벌 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용합니다.
obj[key] = "value";
console.log(obj[key]); // value
```

[⬆ Back to top](#목차)
<br />

## 8. 기본형 vs 참조형

그런데 어떤 기준으로 기본형과 참조형을 구분하는 걸까요? 일반적으로 기본형은 할당이나 연산시 값이 복제되고, 참조형은 값이 참조된다고 알려져 있습니다. 하지만 엄밀히 말하면 두 타입 모두 할당이나 연산시 복제가 일어납니다. 다만 **기본형은 값이 담긴 주솟값을 바로 복제**하는 반면, **참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제**합니다.

### 8-1. 기본형(원시 타입)의 불변성

불변성(immutability)에 대해 이야기하면 변수(variable)와 상수(constant)가 떠오를 수 있습니다. 이 둘을 구분하는 것은 ‘변경 가능성’입니다. 바꿀 수 있으면 변수, 바꿀 수 없으면 상수입니다.

이 불변값과 상수를 오해하기 쉬운데, 이는 구분이 필요합니다. **변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리**입니다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부에 따라 둘을 구분지을 수 있습니다. 반면, **불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역 메모리**입니다.

기본형은 모두 불변값입니다. 다음 예시 코드를 보고 더 자세히 알아보겠습니다.

```jsx
var b = 5;
var c = 5;
b = 7;
```

1번째 줄에서 변수 `b`에 숫자 5를 할당하면 컴퓨터는 일단 데이터 영역에서 5를 찾고, 없으면 데이터 공간 하나를 만들어 5를 저장합니다. 그리고 그 주소를 식별자 `b`에 저장합니다.

2번째 줄에서 변수 `c`에 5를 할당하려고 합니다. 이미 만들어놓은 값이 있으니 이 주소를 재활용해서 `c`에 할당합니다.

3번째 줄에서는 변수 `b`의 값을 7로 바꾸고자 합니다. 그러면 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어서 `b`에 저장합니다. 결국 5와 7모두 다른 값으로는 변경할 수 없습니다.

변경은 새로 만드는 동작을 통해서만 이뤄집니다. 이것이 바로 불변값의 성질이며, **한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않습니다**.

### 8-2. 참조형(객체 타입)의 가변성

기본형 데이터는 모두 불변값입니다. 그렇다면 참조형 데이터는 모두 가변값일까요? **기본적인 성질은 가변값**인 경우가 많지만 설정에 따라 변경 불가능한 경우(`Object.freeze` 등)도 있고, 아예 불변값으로 활용하는 방안도 있습니다.

우선 참조형 데이터를 변수에 할당하는 과정을 확인해보겠습니다.

```jsx
var obj1 = {
  a: 1,
  b: "bbb",
};
```

| 주소(변수 영역)     | 1001      | 1002                      | 1003 | 1004  | …   |
| ------------------- | --------- | ------------------------- | ---- | ----- | --- | --- |
| 데이터(변수 영역)   |           | 이름: obj1<br />값: @5001 |      |       |     |     |
| 주소(데이터 영역)   | 5001      | 5002                      | 5003 | 5004  | …   |
| 데이터(데이터 영역) | @7103 ~ ? |                           | 1    | ‘bbb’ |     |

1. 우선 컴퓨터는 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj1로 지정합니다.
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹입니다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ ?)를 @5001에 저장합니다.

| 주소(객체 @5001의 변수 영역)   | 7103                   | 7104                   | 7105 | 7106 | …   |
| ------------------------------ | ---------------------- | ---------------------- | ---- | ---- | --- |
| 데이터(객체 @5001의 변수 영역) | 이름: a<br />값: @5003 | 이름: b<br />값: @5004 |

3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정합니다.
4. 데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장합니다. 문자열 ‘bbb’ 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장합니다.

기본형과 참조형의 차이가 조금 보이시나요? **기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재한다**는 점입니다. **객체가 별도로 할애한 영역은 변수 영역일 뿐 ‘데이터 영역’은 기존의 메모리 공간을 그대로 활용**합니다. **데이터 영역에 저장된 값은 모두 불변값이지만, 변수에는 다른 값을 얼마든지 대입할 수 있습니다**. 바로 이 부분 때문에 흔히 참조형 데이터는 불변(immutable)하지 않다(가변값이다)라고 하는 것이죠.

```jsx
var obj1 = {
  a: 1,
  b: "bbb",
};

obj1.a = 2;
```

위 객체 `obj1`에서 프로피터 `a`에 2를 할당하려고 합니다. 만약 기본형(원시 타입)이었다면, 객체를 새로 생성했겠지만, 이 경우 프로퍼티 `a`가 가리키는 데이터 영역의 주소만 변경될 뿐 객체는 새로 생성되지 않습니다. 즉, **‘새로운 객체’가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐** 것이죠.

### 8-3. 변수 복사에서의 차이

```jsx
// 기본형
var a = 10;
var b = a;

// 참조형
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

위 코드를 실행하면 식별자 `a`와 `b`는 10이 담긴 데이터 영역의 주소를 가리키고, 식별자 `obj1`과 `obj2`는 `{ c: 10, d: ‘ddd’ }`를 가리키는 데이터 영역의 주소를 가리킵니다. 변수를 복사하는 과정은 **기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일**합니다.

그러나 복사 과정은 동일하지만 데이터 할당 과정에서 차이가 있기 때문에, 변수 복사 이후의 동작에 큰 차이가 발생합니다.

```jsx
// 기본형
var a = 10;
var b = a;
b = 15;

// 참조형
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
obj2.c = 20;
```

위 코드를 실행하면 어떻게 될까요?

기본형의 경우부터 보겠습니다. 15라는 값이 없으니 데이터 영역에 임의의 공간에 값 15를 생성하고, `b`에 할당합니다. 결과적으로 `a`와 `b`는 서로 다른 주소를 바라보며 `a`는 10, `b`는 15가 됩니다.

참조형의 경우도 20이라는 값이 없으니 데이터 영역에 임의의 공간에 값 20을 생성하고, 그 주소를 가지고 변수 영역에서 `obj2`를 찾고, `obj2`가 가리키는 객체 변수 영역에서 다시 `c`를 찾아 그곳에 20이 담긴 주소를 대입합니다.

이제 `obj1`과 `obj2`는 다른 객체일까요? 아닙니다. 프로퍼티 `c`의 값이 바뀌었지만, 둘은 동일한 객체를 참조하고 있습니다. 즉 해당 객체의 프로퍼티 `c`가 가리키는 값이 변경된 것일 뿐입니다.

```jsx
console.log(a === b); // false
console.log(obj1 === obj2); // true
```

이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점입니다. 대부분 기본형은 값을 복사하고, 참조형은 주솟값을 복사한다고 알고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없습니다. 다만 **기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다**는 차이가 있습니다.

```jsx
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

obj2 = { c: 20, d: "ddd" };
```

이 경우는 어떨까요? 이번에는 원래 `obj2`가 `obj1`과 같은 객체를 가리키고 있었지만, `obj2`에 새로운 객체를 할당함으로써 값을 직접 변경했습니다. 그러므로 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 `obj2` 위치에 저장할 것입니다. 객체에 대한 변경임에도 값이 달라진 것입니다.

즉, **참조형 데이터가 ‘가변값’이라고 설명할 때의 ‘가변’은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립**합니다.

[⬆ Back to top](#목차)
<br />

## 9. 데이터 타입의 필요성

데이터 타입은 왜 필요할까요? **값은 메모리에 저장하고 참조할 수 있어야 합니다**. **메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 합니다**. 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알기 위해서죠. 다음 코드를 보겠습니다.

```jsx
var score = 100;
```

위 코드를 실행하면 컴퓨터는 숫자 값을 저장하기 위해 메모리 공간을 확보한 다음, 확보된 메모리에 숫자 값 100을 2진수로 저장합니다. 이러한 처리를 하려면 숫자 **값을 저장할 때, 확보해야 할 메모리 공간의 크기를 알아야 합니다**.

**자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보**합니다.즉, **변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정**됩니다.

위 예제의 경우 자바스크립트 엔진은 리터럴 100을 숫자 타입의 값으로 해석하고 숫자 타입의 값 100을 저장하기 위해 8바이트 메모리 공간을 확보합니다. 그리고 100을 **2진수로 저장**합니다.

이번에는 값을 참조하는 경우를 생각해보겠습니다. 식별자 `score`를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있습니다.

이때 **값을 참조하려면 한 번에 읽어들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 합니다**. score 변수에는 숫자 타입의 값이 할당되어 있으므로 8바이트 단위로 저장되고, 자바스크립트는 8바이트 단위로 메모리 공간에 저장된 값을 읽어들입니다.

그렇다면 메모리에 저장된 2진수 데이터를 어떻게 해석할까요? 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장됩니다. **메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있습니다**. 예를 들어, 메모리에 저장된 값 `0100 0001`을 숫자로 해석하면 65지만, 문자열로 해석하면 ‘A’입니다.

데이터 타입에 대해 다시 한 번 정리하자면, 데이터 타입은 값의 종류를 말합니다. 자바스크립트의 모든 값은 데이터 타입을 가집니다. 데이터 타입이 필요한 이유는 다음과 같습니다.

- **값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해**
- **값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해**
- **메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해**

[⬆ Back to top](#목차)
<br />

## 10. 동적 타이핑

C언어와 같은 정적 타입(static type) 언어는 변수를 선언할 때, 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 합니다. 이를 명시적 타입 선언(explicit type declaration)이라고 합니다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있습니다. 정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행합니다. 만약 타입 체크를 통과하지 못하면 에러를 발생시키고 프로그램의 실행 자체를 막습니다. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄입니다.

자바스크립트는 정적 타입 언어와 달리 변수를 선언할 때 타입을 선언하지 않습니다. 그저 var, let, const 키워드를 사용해 변수를 선언할 뿐이죠. **자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니라 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있습니다**.

```jsx
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = "Hello";
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {};
console.log(typeof foo); // object

foo = [];
console.log(typeof foo); // object

foo = function () {};
console.log(typeof foo); // function
```

변수 선언 시점에 타입이 결정되고 변수의 타입을 변경할 수 없는 정적 타입 언어와 달리 **자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경할 수 있습니다**.

다시 말해, **자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론; type inference)됩니다**. 그리고 **재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있습니다**. 이러한 특징을 **동적 타이핑(dynamic typing)** 이라고 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 **동적 타입(dynamic type) 언어**라고 합니다.

변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있습니다. 그뿐만 아니라 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있습니다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없습니다.

더욱이 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 결국 **동적 타입 언어는 유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어집니다**.

이러한 이유로 안정적인 프로그램을 만들기 위해 변수를 사용하기 이전에 데이터 타입을 체크해야 하는 경우가 있는데 이는 매우 번거로울뿐더러 코드의 양도 증가합니다. 따라서 변수를 사용할 때 주의할 사항은 다음과 같습니다.

- **변수는 꼭 필요한 경우에 한해 제한적으로 사용**합니다.
- **변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제**해야 합니다.
- **전역 변수는 최대한 사용하지 않도록 합니다**.
- **변수보다는 상수를 사용해 값의 변경을 억제**합니다.
- **변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍**합니다.

[⬆ Back to top](#목차)
<br />
