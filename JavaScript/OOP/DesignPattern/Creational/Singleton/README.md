# 싱글톤 패턴(Singleton Pattern)

## 싱글톤 패턴이란?

싱글톤 패턴은 전역 변수를 사용하지 않고 **오직 하나의 객체(인스턴스)만을 만들고, 생성된 객체를 어디서든 접근할 수 있도록 하는 패턴**입니다.

싱글톤 패턴을 따르는 클래스는 **생성자가 여러 차례 호출되더라도 실제로 생성되는 객체(인스턴스)는 하나이고, 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 반환**합니다. 주로 공통된 객체를 여러 개 생성해서 사용하는 DBCP(Database Connection Pool)와 같은 상황에서 많이 사용된다고 합니다.

싱글톤 패턴은 전역 변수와 거의 동일한 장단점을 가집니다. 매우 편리하지만 코드의 모듈성을 깨뜨립니다. 많은 개발자가 싱글톤 패턴을 안티 패턴으로 간주하기 때문에, 타입스크립트 코드에서는 점점 사용이 감소하고 있습니다.

### 문제

싱글톤 패턴은 단일 책임 원칙을 위반하여, 두 가지 문제를 해결합니다.

1. **클래스가 하나의 객체(인스턴스)만 가져야 합니다.**

   클래스가 가진 인스턴스의 개수를 왜 제어하려고 할까요? 가장 일반적인 이유는 일부 공유 자원(DB 또는 파일)에 대한 접근을 제어하기 위해서입니다.
   예를 들어 여러분이 어떤 객체를 생성했지만, 잠시 후에 새로운 객체를 만들기로 결정했다고 생각해봅시다. 싱글톤 패턴에서는 새로운 객체를 받는 대신에 이미 만든 객체를 얻게 됩니다. 생성자 호출은 항상 새로운 객체를 반환되도록 설계되었기 때문에, 이 동작은 일반적인 생성자로 구현할 수 없다는 것을 주의해야 합니다.

2. **해당 객체(인스턴스)에 대한 전역 접근(global access) 지점을 제공합니다.**

   몇몇 필수적인 객체를 저장하기 위해 전역 변수를 사용한 적이 있으신가요? 매우 편리한 방법이지만, 이 전역 변수들은 어떤 코드도 잠재적으로 이 변수들의 내용을 덮어쓸 수 있고 어플리케이션을 손상시킬 수 있기 때문에 매우 안전하지 않습니다.
   전역 변수와 마찬가지로 싱글톤 패턴을 사용하면 프로그램의 모든 곳에서 특정한 객체에 접근할 수 있습니다. 그러나 다른 코드에 의해 해당 객체(인스턴스)가 덮어쓰여지지 않도록 보호하는 역할을 합니다.

   이 문제의 또 다른 측면은 문제 1(클래스가 하나의 객체만을 가지게 하는)을 해결하는 코드들이 프로그램 전체에 흩어져 있기 원하지 않는다는 것입니다. 특히 코드의 나머지 부분이 해당 클래스에 의존하는 경우에는 한 클래스 내에 있는 것이 훨씬 좋습니다.

요즘은 싱글톤 패턴은 대중화 되어 사람들은 이 문제들 중 하나만 해결하더라도 사람들은 그것을 싱글톤이라고 부릅니다.

### 해결책

모든 싱글톤 패턴의 구현에는 다음 두 단계를 공통적으로 가집니다.

- 다른 객체가 싱글톤 클래스와 함께 `new` 연산자를 사용하지 못하도록 **기본 생성자를 비공개**로 설정합니다.
- **생성자 역할을 하는 정적 생성 메서드**를 만듭니다. 내부적으로 이 메서드는 객체를 만들어 정적 필드에 저장하기 위해 private 생성자를 호출합니다. 이 메서드에 대한 이후의 호출은 저장된(cached) 객체를 반환합니다.

싱글톤 클래스에 접근할 수만 있다면, 싱글톤의 정적 메서드를 호출할 수 있습니다. 따라서 해당 메서드가 호출될 때마다 항상 동일한 객체가 반환됩니다.

## 싱글톤 패턴의 구조

![https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-indexed-2x.png](https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-indexed-2x.png)

[출처: [https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-indexed-2x.png](https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-indexed-2x.png)]

1. 싱글톤 클래스에는 해당 클래스의 동일한 메서드를 반환하는 정적 메서드 getInstance를 정의합니다.

싱글톤의 생성자는 숨겨져 있어야 합니다. `getInstance` 메서드를 호출하는 것이 싱글톤 객체를 가져오는 유일한 수단이어야 합니다.

## 예시 코드

```tsx
/**
 * 싱글톤 클래스에는 getInstance 메서드를 정의합니다.
 * 이 메서드는 클라이언트 코드에서 유일한 싱글톤 객체를 접근할 수 있게 해줍니다.
 */
class Singleton {
  private static instance: Singleton;

  /**
   * 싱글톤의 생성자는 new 연산자를 이용한 직접 생성 호출을 막기 위해
   * 항상 private이어야 합니다.
   */
  private constructor() {}

  /**
   * 싱글톤 객체로의 접근을 제어하기 위한 정적 메서드입니다.
   *
   * 이 구현을 통해 싱글톤 클래스의 각 하위 클래스들의 인스턴스를 하나로 유지하면서
   * 싱글톤 클래스를 하위 클래스화할 수 있습니다.
   */
  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }

    return Singleton.instance;
  }

  /**
   * 싱글톤 인스턴스에서 실행될 비즈니스 로직을 정의합니다.
   */
  public someBuisnessLogic() {
    // ...
  }
}

function clientCode() {
  const s1 = Singleton.getInstance();
  const s2 = Singleton.getInstance();

  if (s1 === s2) {
    console.log(
      "싱글톤이 동작합니다. 두 변수에는 같은 인스턴스가 담겨 있습니다."
    );
  } else {
    console.log(
      "싱글톤이 실패했습니다. 변수들이 다른 인스턴스를 가지고 있습니다."
    );
  }
}

clientCode(); // 싱글톤이 동작합니다. 두 변수에는 같은 인스턴스가 담겨 있습니다.
```

- [다른 예시 1](./printer.ts)
- [다른 예시 2](./cart.ts)

## 언제 사용해야할까?

- **인스턴스가 한 개만 존재하는 것을 보장하고 싶은 경우**
- **프로그램에서 전역에서 사용할 데이터를 공유할 객체가 필요한 경우**
- **전역 변수를 조금 더 엄격한 방식으로 제어해야 하는 경우**

## 구현 방법

1. 싱글톤 인스턴스를 저장하기 위해 클래스에 private static 필드를 추가합니다.
2. 싱글톤 인스턴스를 얻기 위한 **공용 정적 생성 메서드**(public static creation method)를 선언합니다.
3. 정적 메서드 내에서 “**지연 초기화(lazy initialization, 인스턴스를 실제 사용하는 시점에서 생성하는 방법으로 동적 바인딩 기법입니다)**”를 구현합니다. 첫 번째 호출에서 새 객체를 만들고 정적 필드에 넣어준 다음 모든 후속 호출에서 항상 해당 인스턴스를 반환합니다.
4. 클래스의 생성자를 private으로 만듭니다. 클래스의 정적 메서드는 여전히 생성자를 호출할 수 있지만, 다른 객체는 호출할 수 없습니다.
5. 클라이언트 코드를 살펴보고 싱글톤의 생성자에 대한 모든 직접 호출을 정적 생성 메서드에 대한 호출로 바꿉니다.

## 장점과 단점

### 장점

- 클래스에 인스턴스가 하나만 있음을 보장합니다.
- 해당 인스턴스에 대한 **전역 접근이 가능해 데이터의 공유가 용이**합니다.
- 싱글톤 객체는 처음 요청될 때만 초기화되므로 **메모리 낭비를 방지**할 수 있습니다.

### 단점

- 단일 책임 원칙을 위반합니다.
- 프로그램의 구성 요소가 서로에 대해 너무 많이 알고 있는 경우 잘못된 설계를 가릴 수 있습니다.
- 다중 스레드 환경에서 특별한 처리가 필요합니다.
- 많은 테스트 프레임워크가 모의 객체를 생성할 때, 상속에 의존하기 때문에 단위 테스트가 어려울 수 있습니다. 싱글톤 클래스의 생성자는 비공개이고, 대부분의 언어에서 정적 메서드를 재정의하는 것이 불가능하기 때문에 싱글톤을 테스트할 창의적인 방법을 떠올려야 합니다.

## 다른 패턴과의 관계

- 대부분의 경우 [퍼사드](../../Structural/Facade/) 패턴은 단일 퍼사드 객체로 충분하기 때문에 [싱글톤](https://www.notion.so/Singleton-Pattern-9e6d45cff1e34428a7b6fdd8d5de8199)으로 변환될 수 있습니다.
- [플라이웨이트](../../Structural/Flyweight/) 패턴은 객체의 모든 공유 상태를 단 하나의 플라이웨이트 객체로 줄일 수 있다면, [싱글톤](../Singleton/)과 비슷할 수 있습니다. 하지만 두 가지 차이가 있습니다.
  1. 단 하나의 싱글톤 인스턴스가 있어야 하는 반면, 플라이웨이트 클래스는 고유 상태가 다른 여러 인스턴스를 가질 수 있습니다.
  2. 싱글톤 객체는 변경할 수 있지만, 플라이웨이트 객체는 변경할 수 없습니다.
- [추상 팩토리 클래스](https://www.notion.so/Design-Pattern-be5c2addc0d14f49a58bc4c20643a41b), [빌더](https://www.notion.so/Builder-Pattern-1b84a9252ac046078a4015bfa595ee82) 및 [프로토타입](https://www.notion.so/Prototype-Pattern-9ed885596b184d9aaae4984b0569e73f) 패턴은 모두 [싱글톤](https://www.notion.so/Singleton-Pattern-9e6d45cff1e34428a7b6fdd8d5de8199) 패턴으로 구현될 수 있습니다.
