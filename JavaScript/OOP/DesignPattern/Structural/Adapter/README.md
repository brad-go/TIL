# 어댑터 패턴(Adapter Pattern)

## 어댑터 패턴이란?

어댑터 패턴은 **호환되지 않는 인터페이스를 가진 객체들을 협업할 수 있도록 하는 구조적 디자인 패턴**입니다. 어댑터 패턴은 적응자 패턴이라고도 불리며, **서로 다른 인터페이스를 사용할 수 있도록 바꿔줌으로 기존 코드를 재사용할 수 있게 해줍니다**. 즉, 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 역할을 합니다.

간단하게 국가마다 다른 전원 플러그 및 소켓 표준을 떠올려볼 수 있습니다. 한국에서는 220V를 사용하지만 미국은 110V를 사용합니다. 이럴 때 전원 플러그 어댑터를 사용하면 문제를 해결할 수 있습니다. 어댑터 패턴은 이와 비슷한 원리로 **하나의 객체에 대한 호출을 포착하고, 두번째 객체가 인식할 수 있는 타입과 인터페이스로 변환**합니다.

**기존에 있는 시스템에 새로운 써드파티 라이브러리가 추가된다던지, 기존 인터페이스를 새로운 인터페이스로 교체하는 경우에 코드의 재사용성을 높일 수 있는 해결책**이 될 수 있습니다. 타입스크립트에서 매우 흔하게 사용되며, 일부 레거시 코드를 최신 클래스에서 동작하도록 도와줍니다.

### 문제

주식 시장 모니터링 앱을 만들고 있다고 상상해봅시다. 이 앱은 XML 형식의 여러 주식 데이터를 다운로드한 다음 사용자에게 보기 좋은 차트와 다이어그램을 표시합니다.

어느 날, 스마트한 타사의 분석 라이브러리를 통합하여 앱을 개선하기로 결정합니다. 하지만 이 분석 라이브러리는 JSON 형식의 데이터에서만 작동한다는 문제가 있습니다. 즉, 앱과 호환되지 않는 형식의 데이터를 사용하기 때문에 분석 라이브러리를 “있는 그대로" 사용할 수는 없습니다.

XML과 함께 동작하도록 라이브러리를 변경한다면 라이브러리에 의존하는 일부 기존 코드가 손상될 수 있습니다. 더군다나 처음부터 라이브러의 소스 코드에 접근할 수 없어서 이 접근 방식이 불가능할 수도 있습니다.

### 해결책

**한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환**하는 특별한 객체인 어댑터를 통해 이를 해결할 수 있습니다.

어댑터는 복잡한 변환 과정을 숨기기 위해 객체 중 하나를 감쌉니다. 감싸진 객체는 어댑터를 인식하지도 못합니다. 예를 들어 km 단위로 동작하는 객체에 모든 데이터를 feet나 mile과 같은 영국식 단위로 변환하는 어댑터로 감쌀 수 있습니다.

어댑터는 데이터를 다양한 타입으로 변환할 수 있을 뿐만 아니라 다양한 인터페이스를 가진 객체가 협업하는 데 도움이 될 수 있습니다. 어댑터는 다음과 같이 동작합니다:

1. 어댑터는 기존 객체 중 하나와 호환되는 인터페이스를 가져옵니다.
2. 이 인터페이스를 사용하면 기존 객체가 어댑터의 메서드를 안전하게 호출할 수 있습니다.
3. 호출을 수신하면 어댑터는 요청을 두 번째 객체에 전달하지만 두 번째 객체가 예상하는 형식과 순서로 전달합니다.

때때로 양방향으로 호출을 변환할 수 있는 양방향 어댑터의 생성도 가능합니다.

다시 주식 시장 앱으로 돌아와서 호환되지 않는 형식의 딜레마를 해결하기 위해 분석 라이브러리의 모든 클래스에 대해 XML-JSON 어댑터를 만들 수 있습니다. 그런 다음 이러한 어댑터를 통해서만 라이브러리와 통신하도록 코드를 수정할 수 있습니다. 어댑터가 호출을 수신하면 들어오는 XML 데이터를 JSON 구조로 변환하고 호출을 감싸진 분석 객체의 적절한 메서드에 전달합니다.

## 어댑터 패턴의 구조

이 구현 방식은 객체 구성 원칙을 사용합니다: 어댑터는 한 객체의 인터페이스를 구현하고, 다른 하나를 감쌉니다. 이러한 방식을 객체 어댑터 방식이라고 하며 대부분의 프로그래밍 언어에서 구현이 가능합니다. (다중 상속을 지원하는 프로그래밍 언어에서는 클래스 어댑터 방식으로도 구현이 가능합니다)

![https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed-2x.png](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed-2x.png)

[출처: [https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed-2x.png](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed-2x.png)]

1. **Client**: 클라이언트는 기존 프로그램의 비즈니스 로직을 포함하는 클래스입니다.
2. **Clinet Interface**: 클라이언트 코드와 협업할 수 있도록 다른 클래스가 따라야 하는 프로토콜을 나타냅니다.
3. **Service**: 서비스는 유용한 클래스(일반적으로 타사 또는 레거시)입니다. 클라이언트는 호환되지 않는 인터페이스를 가지고 있기 때문에 이 클래스를 직접 사용할 수 없습니다.
4. Adapter: 어댑터는 클라이언트와 서비스 모두에서 작동할 수 있는 클래스입니다. 이 클래스는 서비스 객체를 감싸면서 클라이언트 인터페이스를 구현합니다. 어댑터는 어댑터 인터페이스를 통해 클라이언트의 호출을 수신하고, 이해할 수 있는 형식으로 감싸진 서비스 객체에 대한 호출로 변환합니다.
5. 클라이언트 코드는 클라이언트 인터페이스를 통해 어댑터와 함께 작동하는 한 구체적인 어댑터 클래스에 연결되지 않습니다. 덕분에 기존 클라이언트 코드를 손상시키지 않고, 새로운 유형의 어댑터를 프로그램에 도입할 수 있습니다. 이는 서비스 클래스의 인터페이스가 변경되거나 대체될 때, 유용할 수 있습니다. 클라이언트 코드를 변경하지 않고, 새 어댑터 클래스를 생성하기만 하면 됩니다.

## 예시 코드

```tsx
/**
 * 타겟에는 클라이언트 코드에서 사용하는 도메인 별 인터페이스를 정의합니다.
 */
class Target {
  request(): string {
    return "타겟: 기본 타겟의 동작";
  }
}

/**
 * Adaptee(서드 파티, 레거시 등)에는 유용한 동작이 있지만, 인터페이스가 기존의
 * 클라이언트 코드와 호환되지 않습니다. Adaptee는 클라이언트 코드를 사용하기 전에
 * 변환이 필요합니다.
 */
class Adaptee {
  specificRequest(): string {
    return "동작 한별특 의eetpadA";
  }
}

/**
 * 어댑터는 Adaptee의 인터페이스를 타겟의 인터페이스와 호환될 수 있도록 해줍니다.
 */
class Adapter extends Target {
  private adaptee: Adaptee;

  constructor(adaptee: Adaptee) {
    super();
    this.adaptee = adaptee;
  }

  request(): string {
    const result = this.adaptee.specificRequest().split("").reverse().join("");
    return `어댑터: (변환됨) ${result}`;
  }
}

/**
 * 클라이언트 코드는 타겟 인터페이스를 따르는 모든 클래스를 지원합니다.
 */
function clientCode(target: Target) {
  console.log(target.request());
}

console.log("클라이언트: 타겟 객체와 함께 동작할 수 있습니다.");
const target = new Target();
clientCode(target);

console.log("");

const adaptee = new Adaptee();
console.log(
  "클라이언트: Adaptee 클래스는 이상한 인터페이스를 가져서 이해할 수 없습니다."
);
console.log(`Adaptee: ${adaptee.specificRequest()}`);

console.log("");

console.log("클라이언트: 하지만 어댑터를 통해 함께 동작할 수 있습니다.");
const adapter = new Adapter(adaptee);
clientCode(adapter);

// 클라이언트: 타겟 객체와 함께 동작할 수 있습니다.
// 타겟: 기본 타겟의 동작

// 클라이언트: Adaptee 클래스는 이상한 인터페이스를 가져서 이해할 수 없습니다.
// Adaptee: 동작 한별특 의eetpadA

// 클라이언트: 하지만 어댑터를 통해 함께 동작할 수 있습니다.
// 어댑터: (변환됨) Adaptee의 특별한 작동
```

- [다른 예시](./login.ts)
- [다른 예시](./printer.ts)

## 언제 사용해야할까?

- **기존 클래스를 사용하고 싶지만, 해당 인터페이스가 나머지 코드와 호환되지 않는 경우** 어댑터 클래스를 사용합니다. 어댑터 패턴을 사용하면 코드와 레거시 클래스, 타사 클래스 또는 이상한 인터페이스가 있는 다른 클래스 간의 변환기 역할을 하는 중간 계층 클래스를 만들 수 있습니다.
- **슈퍼 클래스에 추가할 수 없는 몇 가지 공통 기능이 없는 기존의 여러 서브 클래스를 재사용하려는 경우**
- 두 가지 이상의 구조에서 유연하게 **전환**하고 싶을 때 사용합니다. 뒤의 인자만 바꾸면 구조가 교체되기 때문에 간단하기 때문입니다.

## 구현 방법

1. 호환되지 않는 인터페이스가 있는 클래스가 두 개 이상 있는지 확인합니다.
   - 변경할 수 없는 유용한 서비스 클래스(써드파티, 레거시나 이미 존재하는 많은 의존성들)
   - 서비스 클래스를 사용하여 이점을 얻을 수 있는 하나 이상의 클라이언트 클래스
2. 클라이언트 인터페이스를 선언하고, 클라이언트가 서비스와 통신하는 메서드를 작성합니다.
3. 어댑터 클래스를 만들고 클라이언트 인터페이스를 따르도록 합니다. 지금은 모든 메서드를 비워둡니다.
4. 서비스 객체에 대한 참조를 저장할 필드를 어댑터 클래스에 추가합니다. 일반적인 방법은 생성자를 통해 이 필드를 초기화하는 것이지만, 때로는 메서드를 호출할 때 어댑터에 전달하는 것이 더 편리합니다.
5. 어댑터 클래스에서 클라이언트 인터페이스의 모든 메서드를 하나씩 구현합니다. 어댑터는 인터페이스 또는 데이터 형식 변환만 처리하면서 실제 작업의 대부분을 서비스 객체에 위임합니다.
6. 클라이언트는 클라이언트 인터페이스를 통해 어댑터를 사용합니다. 이렇게 하면 클라이언트 코드에 영향을 주지 않고 어댑터를 변경하거나 확장할 수 있습니다.

## 장점과 단점

### 장점

- **프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리**하므로 **단일 책임 원칙을 준수**합니다.
- 클라이언트 인터페이스를 통해 어댑터와 함께 작동하는 한 기존 클라이언트 코드를 손상시키지 않고, 새로운 타입의 어댑터를 프로그램에 도입할 수 있습니다. 즉, **개방 폐쇄의 원칙**을 준수합니다.

### 단점

- 새로운 인터페이스와 클래스들을 생성해야 하기 때문에 코드의 전반적인 복잡성이 증가합니다. **때로는 코드의 나머지 부분과 일치하도록 서비스 클래스를 변경하는 것이 더 간단**합니다.

## 다른 패턴과의 관계

- [브릿지 패턴](../Bridge/)은 일반적으로 사전에 설계되어 서로 독립적으로 응용 프로그램의 일부를 개발할 수 있습니다. 반면에 [어댑터 패턴](../Adapter/)은 일반적으로 기존 앱과 함게 사용되어 호환되지 않는 일부 클래스가 잘 동작하도록 해줍니다.
- [어댑터 패턴](../Adapter/)은 기존 객체의 인터페이스를 변경하는 반면, 데코레이터 패턴은 인터페이스를 변경하지 않고 객체를 향상시킵니다. 또한 데코레이터는 재귀적인 결합을 지원하는데, 어댑터는 불가능합니다.
- [어댑터 패턴](../Adapter/)은 감싸진 객체에 대해 다른 인터페이스를 제공하고, 프록시 패턴은 동일한 인터페이스를 제공하며 데코레이터 패턴은 향상된 인터페이스를 제공합니다.
- 퍼사드 패턴은 기존 객체에 대한 새 인터페이스를 정의하는 반면 [어댑터 패턴](../Adapter/)은 기존 인터페이스를 사용 가능하게 만들려고 합니다. 어댑터는 일반적으로 하나의 객체만 감싸는 반면, 퍼사드는 객체의 전체 하위 시스템과 함께 동작합니다.
- [브릿지](../Bridge/), 상태, 전략(및 [어댑터 패턴](../Adapter/))은 매우 유사한 구조를 가지고 있습니다. 실제로 이러한 모든 패턴은 작업을 다른 객체에 위임하는 구성을 기반으로 합니다. 그러나 그들은 모두 다른 문제를 해결합니다.

## 참고

- [Adapter](https://refactoring.guru/design-patterns/adapter)
- [개발하는 만두님 블로그](https://dev-youngjun.tistory.com/210?category=937057)
- [어댑터 패턴](https://dev-momo.tistory.com/entry/Adapter-Pattern-%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4?category=582457)
