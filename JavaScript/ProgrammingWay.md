# [JavaScript] 명령형 프로그래밍 vs 선언형 프로그래밍

> 명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가와 가깝다.

프로그래밍을 하다보면 명령형 프로그래밍과 선언형 프로그래밍에 대한 비교를 접하게 됩니다. 이 둘이 실제로 무엇을 의미하는지 검색하다보면 위와 같은 정의를 마주하게 됩니다. 위 정의를 처음보면 무슨 말을 하는지 이해하기 어렵지만, 이 정의에는 명령형 프로그래밍과 선언형 프로그래밍의 핵심이 담겨있습니다.

## 명령형 프로그래밍(Imperative programming)

명령형 프로그래밍은 코드로 원하는 결과를 달성해 나가는 **과정**에만 관심을 두는 프로그래밍 스타일입니다.

## 선언형 프로그래밍 (Declarative programming)

선언형 프로그래밍은 필요한 것을 달성하는 과정을 하나하나 기술하는 것보다 필요한 것이 어떤 것인지, 즉 **무엇**인지 기술하는데 방점을 두고 애플리케이션의 구조를 세워 나가는 프로그래밍 구조입니다.

- 함수형 프로그래밍은 선언적 프로그래밍이란 더 넓은 패러다임의 한 가지입니다.

> 선언형 방식이 제대로 동작하기 위해서는 명령형으로 '어떻게'가 구현된 것들이 추상화되어 있어야 한다.

간단한 HTML 예제를 통해 알아봅시다.

```html
<article>
  <header>
    <h1>Declarative Programming</h1>
    <p>Sprinkle Declarative in your verbiage to sound smart</p>
  </header>
</article>
```

HTML을 다룬적이 있다면 이 HTML 코드를 통해서 **무엇**이 일어나고 있는지 정확히 알 수 있을 것입니다. 이 예제는 선언형 프로그래밍이며 원하는 것을 '**어떻게**' 수행하는 것보다 '**무엇을**' 수행하는지에 대해 관심이 있습니다. 실제로 이 HTML 코드는 웹 브라우저가 어떻게 HTML 문서를 파싱하고 보여주는 지에 대한 방법은 관심이 없습니다. 어떻게 그것을 달성해야 하는지에 대한 설명 없이 **무엇을** 달성하려 하는지에 대해서만 기술되어 있습니다.

## 예제를 통한 두 프로그래밍 방식의 비교

```js
// 배열을 파라미터로 받고 각 요소들의 값에 2를 곱하는 함수
const double = (arr) => {
  let results = [];
  for (let i = 0; i < arr.length; i++) {
    results.push(arr[i] * 2);
  }
  return results;
};
```

```js
// 배열을 파라미터로 받고 각 요소들을 합한 값을 반환하는 함수
const total = (arr) => {
  let results = 0;
  for (let i = 0; i < arr.length; i++) {
    results += arr[i];
  }
  return results;
};
```

```js
// 버튼이 클릭 되었을 때, highlight 클래스를 토글하는 event listener
btn.addEventListener("click", () => {
  this.classList.toggle("highlight");
  this.innerText === "Add Highlight"
    ? (this.innerText = "Remove Highlight")
    : (this.innerText = "Add Highlight");
});
```

위 3가지 예시가 어떤 프로그래밍 방식으로 쓰여졌는지 아시겠나요? 이 세가지 예시들의 공통점이 무엇인지 살펴보면 실제로 필수 요소가 무엇인지 더 잘 식별할 수 있습니다.

#### 세가지 문제점

1. 위 세가지 예시의 공통점은 모두 '어떻게'를 설명하고 있다는 점입니다. 명시적으로 배열을 반복하거나 원하는 기능을 수행하는 방법에 대한 단계를 설명하고 있습니다.

2. 각 예시 모두 '상태(기본적으로 메모리에 저장된 것에 대한 정보 - 변수와 비슷)'의 일부를 변경하고 있습니다. 처음 두 예제는 results란 변수를 만든 후 계속 수정하고 있습니다. 마지막 예제는 변수가 아닌 DOM의 상태를 가지고 있고, DOM의 상태를 수정하고 있습니다.

3. 코드를 보고 무슨 일이 일어나는지 한 번에 이해할 수 없습니다. 코드를 정확하게 이해하려면 발생 가능한 상황(변동 가능한 데이터)을 고려하면서 컴파일러와 같이 코드를 단계별로 살펴봐야 합니다(더 알아보기 쉬운 경우도 있다고 생각합니다).

자, 이제 위의 예시들을 선언형 프로그래밍 방식으로 고치면서 3가지 문제점을 고쳐보겠습니다. 각 예시들은 '어떻게'가 아닌 '무엇'이 일어나는 지를 설명해야 합니다. 그리고 상태를 변경할 수 없으며 한 눈에 읽을 수 있어야 합니다.

```js
const double = (arr) => {
  return (results = arr.map((item) => item * 2));
};
```

```js
const total = (arr) => {
  return arr.reduce((prev, cur) => prev + cur, 0);
};
```

```jsx
<Btn onToggle={handleToggleHight} highlight={state.highlight}>
  {state.buttonText}
</Btn>
```

처음 두 예제에서는 JavaScript에 기본으로 내장된 `map`과 `reduce`를 활용했다. 이는 명령형 방식이 추상화 된 것입니다. **선언형 프로그맹의 중요한 솔루션은 명령형으로 작성된 구현에 대한 추상화**입니다!

1. 모든 예시들은 '어떻게'보다 '무엇'이 이루어지기를 원하는지 설명합니다. map과 reduce가 어떻게 이루어졌는지 알 필요없고 신경 쓸 필요조차 없습니다.

2. 상태를 변경하는 모든 지점들은 map과 reduce 메서드 안쪽으로 추상화되어 직접 상태를 변경하지 않습니다.

3. map과 reduce 함수만 알고 있다면 가독성이 훨씬 좋습니다.

세번째 예제는 `jsx`로 쓰여져 있고, 사실 React 문법입니다. 하지만 이전 예제에서 언급된 세가지 문제는 수정되었고, React가 선언적인 방식으로 UI를 만들 수 있다는 진정한 장점을 알 수 있습니다.

> 선언형 프로그래밍의 또 다른 이점은 프로그램이 상황에 독립적일 수 있다는 것입니다. 명령형 방식의 코드는 현재 상태의 컨텍스트(맥락)에 의존하기 때문에 재사용하기 어려운 경우가 많지만, 선언형 방식의 코드는 달성하고자 하는 것을 무엇인지 만을 나열하기 때문에 동일한 코드를 다른 프로그램에서 **재사용**하기 쉽습니다.

## 정리

- '어떻게'가 아닌 '무엇을' 달성할 지를 나열하는 방식
- 그 '무엇을' '어떻게' 달성할 지는 추상화 되어 있는 것(map, reduce 등)을 사용하거나, 추상화 시킨다.
- 선언형 방식으로 코드를 작성하면 여러 곳에서 재사용하기 비교적 쉽다.

리액트 프로젝트를 진행하다가 바닐라 JS로 프로젝트를 진행하려고 하다보니 코드가 복잡해지고, 재사용성이 떨어진다는 생각을 많이 했습니다. 그러던 중 자바스크립트를 사용하는 새로운 방식에 대해 공부하게 되었고, 마치 리액트처럼 사용하는 방식이었습니다.

이 방식을 공부하다보니 명령형 프로그맹과 선언형 프로그래밍에 대한 개념을 접하게 되었고, 제 코드에 정말 딱 필요한 부분을 공부한 것 같습니다. 얼른 코드를 수정하러 가봐야 겠습니다 :smile:

## 참고

- [명령형 프로그래밍 vs 선언형 프로그래밍](https://boxfoxs.tistory.com/430)
